/* tslint:disable */
/* eslint-disable */
/**
 * HASH Internal API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface CreateStripeSetupIntent200Response
 */
export interface CreateStripeSetupIntent200Response {
  /**
   *
   * @type {string}
   * @memberof CreateStripeSetupIntent200Response
   */
  clientSecret: string;
}
/**
 *
 * @export
 * @interface CreateSubscription200Response
 */
export interface CreateSubscription200Response {
  /**
   *
   * @type {string}
   * @memberof CreateSubscription200Response
   */
  subscriptionId: string;
  /**
   *
   * @type {string}
   * @memberof CreateSubscription200Response
   */
  clientSecret: string;
}
/**
 *
 * @export
 * @interface CreateSubscriptionRequest
 */
export interface CreateSubscriptionRequest {
  /**
   *
   * @type {SubscriptionTier}
   * @memberof CreateSubscriptionRequest
   */
  subscriptionTier: SubscriptionTier;
}
/**
 *
 * @export
 * @interface ErrorInfo
 */
export interface ErrorInfo {
  /**
   *
   * @type {string}
   * @memberof ErrorInfo
   */
  reason: string;
  /**
   *
   * @type {string}
   * @memberof ErrorInfo
   */
  domain: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ErrorInfo
   */
  metadata: { [key: string]: any };
}
/**
 *
 * @export
 * @interface ExternalServiceMethod200Response
 */
export interface ExternalServiceMethod200Response {
  /**
   *
   * @type {any}
   * @memberof ExternalServiceMethod200Response
   */
  externalServiceMethodResponse: any;
}
/**
 *
 * @export
 * @interface ExternalServiceMethodRequest
 */
export interface ExternalServiceMethodRequest {
  /**
   *
   * @type {string}
   * @memberof ExternalServiceMethodRequest
   */
  providerName: ExternalServiceMethodRequestProviderNameEnum;
  /**
   *
   * @type {string}
   * @memberof ExternalServiceMethodRequest
   */
  methodName: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ExternalServiceMethodRequest
   */
  payload: { [key: string]: any };
}

export const ExternalServiceMethodRequestProviderNameEnum = {
  OpenAi: "openai",
  Mapbox: "mapbox",
} as const;

export type ExternalServiceMethodRequestProviderNameEnum =
  (typeof ExternalServiceMethodRequestProviderNameEnum)[keyof typeof ExternalServiceMethodRequestProviderNameEnum];

/**
 *
 * @export
 * @interface GetPaymentMethods200Response
 */
export interface GetPaymentMethods200Response {
  /**
   *
   * @type {Array<StripePaymentMethod>}
   * @memberof GetPaymentMethods200Response
   */
  paymentMethods?: Array<StripePaymentMethod>;
}
/**
 *
 * @export
 * @interface GetSubscription200Response
 */
export interface GetSubscription200Response {
  /**
   *
   * @type {StripeSubscription}
   * @memberof GetSubscription200Response
   */
  subscription?: StripeSubscription;
}
/**
 *
 * @export
 * @interface GetSubscriptionTierPrices200Response
 */
export interface GetSubscriptionTierPrices200Response {
  /**
   *
   * @type {SubscriptionTierPrices}
   * @memberof GetSubscriptionTierPrices200Response
   */
  subscriptionTierPrices: SubscriptionTierPrices;
}
/**
 *
 * @export
 * @interface GetUpcomingInvoice200Response
 */
export interface GetUpcomingInvoice200Response {
  /**
   *
   * @type {StripeInvoice}
   * @memberof GetUpcomingInvoice200Response
   */
  upcomingInvoice?: StripeInvoice;
}
/**
 *
 * @export
 * @interface ResourceInfo
 */
export interface ResourceInfo {
  /**
   *
   * @type {string}
   * @memberof ResourceInfo
   */
  resourceType: string;
  /**
   *
   * @type {string}
   * @memberof ResourceInfo
   */
  resourceName: string;
  /**
   *
   * @type {string}
   * @memberof ResourceInfo
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof ResourceInfo
   */
  description: string;
}
/**
 *
 * @export
 * @interface Status
 */
export interface Status {
  /**
   *
   * @type {StatusCode}
   * @memberof Status
   */
  code: StatusCode;
  /**
   *
   * @type {string}
   * @memberof Status
   */
  message?: string;
  /**
   *
   * @type {Array<StatusContentsInner>}
   * @memberof Status
   */
  contents: Array<StatusContentsInner>;
}
/**
 *
 * @export
 * @enum {string}
 */

export const StatusCode = {
  Ok: "OK",
  Cancelled: "CANCELLED",
  Unknown: "UNKNOWN",
  InvalidArgument: "INVALID_ARGUMENT",
  DeadlineExceeded: "DEADLINE_EXCEEDED",
  NotFound: "NOT_FOUND",
  AlreadyExists: "ALREADY_EXISTS",
  PermissionDenied: "PERMISSION_DENIED",
  Unauthenticated: "UNAUTHENTICATED",
  ResourceExhausted: "RESOURCE_EXHAUSTED",
  FailedPrecondition: "FAILED_PRECONDITION",
  Aborted: "ABORTED",
  OutOfRange: "OUT_OF_RANGE",
  Unimplemented: "UNIMPLEMENTED",
  Internal: "INTERNAL",
  Unavailable: "UNAVAILABLE",
  DataLoss: "DATA_LOSS",
} as const;

export type StatusCode = (typeof StatusCode)[keyof typeof StatusCode];

/**
 * @type StatusContentsInner
 * @export
 */
export type StatusContentsInner = ErrorInfo | ResourceInfo;

/**
 *
 * @export
 * @interface StripeInvoice
 */
export interface StripeInvoice {
  /**
   *
   * @type {string}
   * @memberof StripeInvoice
   */
  currency: string;
  /**
   *
   * @type {number}
   * @memberof StripeInvoice
   */
  amount_due: number;
}
/**
 *
 * @export
 * @interface StripePaymentMethod
 */
export interface StripePaymentMethod {
  [key: string]: any;
}
/**
 *
 * @export
 * @interface StripePrice
 */
export interface StripePrice {
  [key: string]: any;
}
/**
 *
 * @export
 * @interface StripeSubscription
 */
export interface StripeSubscription {
  [key: string]: any;
}
/**
 *
 * @export
 * @enum {string}
 */

export const SubscriptionTier = {
  Hobby: "hobby",
  Pro: "pro",
} as const;

export type SubscriptionTier =
  (typeof SubscriptionTier)[keyof typeof SubscriptionTier];

/**
 *
 * @export
 * @interface SubscriptionTierPrices
 */
export interface SubscriptionTierPrices {
  /**
   *
   * @type {StripePrice}
   * @memberof SubscriptionTierPrices
   */
  hobby: StripePrice;
  /**
   *
   * @type {StripePrice}
   * @memberof SubscriptionTierPrices
   */
  pro: StripePrice;
}
/**
 *
 * @export
 * @interface UpdatePaymentMethod200Response
 */
export interface UpdatePaymentMethod200Response {
  /**
   *
   * @type {StripePaymentMethod}
   * @memberof UpdatePaymentMethod200Response
   */
  updatedPaymentMethod?: StripePaymentMethod;
}
/**
 *
 * @export
 * @interface UpdatePaymentMethodRequest
 */
export interface UpdatePaymentMethodRequest {
  /**
   *
   * @type {UpdatePaymentMethodRequestUpdatedBillingDetails}
   * @memberof UpdatePaymentMethodRequest
   */
  updatedBillingDetails: UpdatePaymentMethodRequestUpdatedBillingDetails;
}
/**
 *
 * @export
 * @interface UpdatePaymentMethodRequestUpdatedBillingDetails
 */
export interface UpdatePaymentMethodRequestUpdatedBillingDetails {
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentMethodRequestUpdatedBillingDetails
   */
  name?: string;
  /**
   *
   * @type {UpdatePaymentMethodRequestUpdatedBillingDetailsAddress}
   * @memberof UpdatePaymentMethodRequestUpdatedBillingDetails
   */
  address?: UpdatePaymentMethodRequestUpdatedBillingDetailsAddress;
}
/**
 *
 * @export
 * @interface UpdatePaymentMethodRequestUpdatedBillingDetailsAddress
 */
export interface UpdatePaymentMethodRequestUpdatedBillingDetailsAddress {
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentMethodRequestUpdatedBillingDetailsAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentMethodRequestUpdatedBillingDetailsAddress
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentMethodRequestUpdatedBillingDetailsAddress
   */
  line1?: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentMethodRequestUpdatedBillingDetailsAddress
   */
  line2?: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentMethodRequestUpdatedBillingDetailsAddress
   */
  postal_code?: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentMethodRequestUpdatedBillingDetailsAddress
   */
  state?: string;
}
/**
 *
 * @export
 * @interface UpdateSubscriptionDefaultPaymentMethodRequest
 */
export interface UpdateSubscriptionDefaultPaymentMethodRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateSubscriptionDefaultPaymentMethodRequest
   */
  updatedDefaultPaymentMethodId: string;
}
/**
 *
 * @export
 * @interface UpdateSubscriptionTier200Response
 */
export interface UpdateSubscriptionTier200Response {
  /**
   *
   * @type {StripeSubscription}
   * @memberof UpdateSubscriptionTier200Response
   */
  updatedSubscription?: StripeSubscription;
}
/**
 *
 * @export
 * @interface UpdateSubscriptionTierRequest
 */
export interface UpdateSubscriptionTierRequest {
  /**
   *
   * @type {SubscriptionTier}
   * @memberof UpdateSubscriptionTierRequest
   */
  updatedSubscriptionTier: SubscriptionTier;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create a stripe setup intent, for the purpose of adding a new payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStripeSetupIntent: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/stripe-setup-intent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription: async (
      createSubscriptionRequest: CreateSubscriptionRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createSubscriptionRequest' is not null or undefined
      assertParamExists(
        "createSubscription",
        "createSubscriptionRequest",
        createSubscriptionRequest,
      );
      const localVarPath = `/subscription`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSubscriptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Detach an existing payment method from a BP user
     * @param {string} paymentMethodId The payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachPaymentMethod: async (
      paymentMethodId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentMethodId' is not null or undefined
      assertParamExists(
        "detachPaymentMethod",
        "paymentMethodId",
        paymentMethodId,
      );
      const localVarPath = `/payment-method`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paymentMethodId !== undefined) {
        localVarQueryParameter["paymentMethodId"] = paymentMethodId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Call an external service method
     * @param {ExternalServiceMethodRequest} externalServiceMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalServiceMethod: async (
      externalServiceMethodRequest: ExternalServiceMethodRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalServiceMethodRequest' is not null or undefined
      assertParamExists(
        "externalServiceMethod",
        "externalServiceMethodRequest",
        externalServiceMethodRequest,
      );
      const localVarPath = `/external-service-method`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        externalServiceMethodRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve the payment methods of the BP user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethods: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/payment-methods`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve the subscription of the BP user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/subscription`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve the subscription tier prices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptionTierPrices: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/subscription-tier-prices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve an upcoming invoice based on a new subscription tier
     * @param {SubscriptionTier} newSubscriptionTier The new subscription tier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpcomingInvoice: async (
      newSubscriptionTier: SubscriptionTier,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'newSubscriptionTier' is not null or undefined
      assertParamExists(
        "getUpcomingInvoice",
        "newSubscriptionTier",
        newSubscriptionTier,
      );
      const localVarPath = `/upcoming-invoice`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (newSubscriptionTier !== undefined) {
        localVarQueryParameter["newSubscriptionTier"] = newSubscriptionTier;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update an existing payment method of the BP user
     * @param {string} paymentMethodId The payment method ID
     * @param {UpdatePaymentMethodRequest} updatePaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentMethod: async (
      paymentMethodId: string,
      updatePaymentMethodRequest: UpdatePaymentMethodRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentMethodId' is not null or undefined
      assertParamExists(
        "updatePaymentMethod",
        "paymentMethodId",
        paymentMethodId,
      );
      // verify required parameter 'updatePaymentMethodRequest' is not null or undefined
      assertParamExists(
        "updatePaymentMethod",
        "updatePaymentMethodRequest",
        updatePaymentMethodRequest,
      );
      const localVarPath = `/payment-method`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (paymentMethodId !== undefined) {
        localVarQueryParameter["paymentMethodId"] = paymentMethodId;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePaymentMethodRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the default payment method of an existing subscription
     * @param {UpdateSubscriptionDefaultPaymentMethodRequest} updateSubscriptionDefaultPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscriptionDefaultPaymentMethod: async (
      updateSubscriptionDefaultPaymentMethodRequest: UpdateSubscriptionDefaultPaymentMethodRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateSubscriptionDefaultPaymentMethodRequest' is not null or undefined
      assertParamExists(
        "updateSubscriptionDefaultPaymentMethod",
        "updateSubscriptionDefaultPaymentMethodRequest",
        updateSubscriptionDefaultPaymentMethodRequest,
      );
      const localVarPath = `/subscription-default-payment-method`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSubscriptionDefaultPaymentMethodRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the subscription tier of an existing subscription
     * @param {UpdateSubscriptionTierRequest} updateSubscriptionTierRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscriptionTier: async (
      updateSubscriptionTierRequest: UpdateSubscriptionTierRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateSubscriptionTierRequest' is not null or undefined
      assertParamExists(
        "updateSubscriptionTier",
        "updateSubscriptionTierRequest",
        updateSubscriptionTierRequest,
      );
      const localVarPath = `/subscription-tier`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSubscriptionTierRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a stripe setup intent, for the purpose of adding a new payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createStripeSetupIntent(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CreateStripeSetupIntent200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createStripeSetupIntent(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Create a subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSubscription(
      createSubscriptionRequest: CreateSubscriptionRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CreateSubscription200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createSubscription(
          createSubscriptionRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Detach an existing payment method from a BP user
     * @param {string} paymentMethodId The payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async detachPaymentMethod(
      paymentMethodId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UpdatePaymentMethod200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.detachPaymentMethod(
          paymentMethodId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Call an external service method
     * @param {ExternalServiceMethodRequest} externalServiceMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async externalServiceMethod(
      externalServiceMethodRequest: ExternalServiceMethodRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ExternalServiceMethod200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.externalServiceMethod(
          externalServiceMethodRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Retrieve the payment methods of the BP user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentMethods(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetPaymentMethods200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPaymentMethods(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Retrieve the subscription of the BP user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubscription(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetSubscription200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Retrieve the subscription tier prices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubscriptionTierPrices(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetSubscriptionTierPrices200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSubscriptionTierPrices(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Retrieve an upcoming invoice based on a new subscription tier
     * @param {SubscriptionTier} newSubscriptionTier The new subscription tier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUpcomingInvoice(
      newSubscriptionTier: SubscriptionTier,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetUpcomingInvoice200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUpcomingInvoice(
          newSubscriptionTier,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Update an existing payment method of the BP user
     * @param {string} paymentMethodId The payment method ID
     * @param {UpdatePaymentMethodRequest} updatePaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePaymentMethod(
      paymentMethodId: string,
      updatePaymentMethodRequest: UpdatePaymentMethodRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UpdatePaymentMethod200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePaymentMethod(
          paymentMethodId,
          updatePaymentMethodRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Update the default payment method of an existing subscription
     * @param {UpdateSubscriptionDefaultPaymentMethodRequest} updateSubscriptionDefaultPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSubscriptionDefaultPaymentMethod(
      updateSubscriptionDefaultPaymentMethodRequest: UpdateSubscriptionDefaultPaymentMethodRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UpdateSubscriptionTier200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSubscriptionDefaultPaymentMethod(
          updateSubscriptionDefaultPaymentMethodRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Update the subscription tier of an existing subscription
     * @param {UpdateSubscriptionTierRequest} updateSubscriptionTierRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSubscriptionTier(
      updateSubscriptionTierRequest: UpdateSubscriptionTierRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UpdateSubscriptionTier200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSubscriptionTier(
          updateSubscriptionTierRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @summary Create a stripe setup intent, for the purpose of adding a new payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStripeSetupIntent(
      options?: any,
    ): AxiosPromise<CreateStripeSetupIntent200Response> {
      return localVarFp
        .createStripeSetupIntent(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription(
      createSubscriptionRequest: CreateSubscriptionRequest,
      options?: any,
    ): AxiosPromise<CreateSubscription200Response> {
      return localVarFp
        .createSubscription(createSubscriptionRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Detach an existing payment method from a BP user
     * @param {string} paymentMethodId The payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachPaymentMethod(
      paymentMethodId: string,
      options?: any,
    ): AxiosPromise<UpdatePaymentMethod200Response> {
      return localVarFp
        .detachPaymentMethod(paymentMethodId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Call an external service method
     * @param {ExternalServiceMethodRequest} externalServiceMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalServiceMethod(
      externalServiceMethodRequest: ExternalServiceMethodRequest,
      options?: any,
    ): AxiosPromise<ExternalServiceMethod200Response> {
      return localVarFp
        .externalServiceMethod(externalServiceMethodRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve the payment methods of the BP user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethods(
      options?: any,
    ): AxiosPromise<GetPaymentMethods200Response> {
      return localVarFp
        .getPaymentMethods(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve the subscription of the BP user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription(options?: any): AxiosPromise<GetSubscription200Response> {
      return localVarFp
        .getSubscription(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve the subscription tier prices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptionTierPrices(
      options?: any,
    ): AxiosPromise<GetSubscriptionTierPrices200Response> {
      return localVarFp
        .getSubscriptionTierPrices(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve an upcoming invoice based on a new subscription tier
     * @param {SubscriptionTier} newSubscriptionTier The new subscription tier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpcomingInvoice(
      newSubscriptionTier: SubscriptionTier,
      options?: any,
    ): AxiosPromise<GetUpcomingInvoice200Response> {
      return localVarFp
        .getUpcomingInvoice(newSubscriptionTier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update an existing payment method of the BP user
     * @param {string} paymentMethodId The payment method ID
     * @param {UpdatePaymentMethodRequest} updatePaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentMethod(
      paymentMethodId: string,
      updatePaymentMethodRequest: UpdatePaymentMethodRequest,
      options?: any,
    ): AxiosPromise<UpdatePaymentMethod200Response> {
      return localVarFp
        .updatePaymentMethod(
          paymentMethodId,
          updatePaymentMethodRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the default payment method of an existing subscription
     * @param {UpdateSubscriptionDefaultPaymentMethodRequest} updateSubscriptionDefaultPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscriptionDefaultPaymentMethod(
      updateSubscriptionDefaultPaymentMethodRequest: UpdateSubscriptionDefaultPaymentMethodRequest,
      options?: any,
    ): AxiosPromise<UpdateSubscriptionTier200Response> {
      return localVarFp
        .updateSubscriptionDefaultPaymentMethod(
          updateSubscriptionDefaultPaymentMethodRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the subscription tier of an existing subscription
     * @param {UpdateSubscriptionTierRequest} updateSubscriptionTierRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscriptionTier(
      updateSubscriptionTierRequest: UpdateSubscriptionTierRequest,
      options?: any,
    ): AxiosPromise<UpdateSubscriptionTier200Response> {
      return localVarFp
        .updateSubscriptionTier(updateSubscriptionTierRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
  /**
   *
   * @summary Create a stripe setup intent, for the purpose of adding a new payment method.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createStripeSetupIntent(
    options?: AxiosRequestConfig,
  ): AxiosPromise<CreateStripeSetupIntent200Response>;

  /**
   *
   * @summary Create a subscription
   * @param {CreateSubscriptionRequest} createSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createSubscription(
    createSubscriptionRequest: CreateSubscriptionRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<CreateSubscription200Response>;

  /**
   *
   * @summary Detach an existing payment method from a BP user
   * @param {string} paymentMethodId The payment method ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  detachPaymentMethod(
    paymentMethodId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<UpdatePaymentMethod200Response>;

  /**
   *
   * @summary Call an external service method
   * @param {ExternalServiceMethodRequest} externalServiceMethodRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  externalServiceMethod(
    externalServiceMethodRequest: ExternalServiceMethodRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ExternalServiceMethod200Response>;

  /**
   *
   * @summary Retrieve the payment methods of the BP user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getPaymentMethods(
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetPaymentMethods200Response>;

  /**
   *
   * @summary Retrieve the subscription of the BP user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getSubscription(
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetSubscription200Response>;

  /**
   *
   * @summary Retrieve the subscription tier prices
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getSubscriptionTierPrices(
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetSubscriptionTierPrices200Response>;

  /**
   *
   * @summary Retrieve an upcoming invoice based on a new subscription tier
   * @param {SubscriptionTier} newSubscriptionTier The new subscription tier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getUpcomingInvoice(
    newSubscriptionTier: SubscriptionTier,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetUpcomingInvoice200Response>;

  /**
   *
   * @summary Update an existing payment method of the BP user
   * @param {string} paymentMethodId The payment method ID
   * @param {UpdatePaymentMethodRequest} updatePaymentMethodRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updatePaymentMethod(
    paymentMethodId: string,
    updatePaymentMethodRequest: UpdatePaymentMethodRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<UpdatePaymentMethod200Response>;

  /**
   *
   * @summary Update the default payment method of an existing subscription
   * @param {UpdateSubscriptionDefaultPaymentMethodRequest} updateSubscriptionDefaultPaymentMethodRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateSubscriptionDefaultPaymentMethod(
    updateSubscriptionDefaultPaymentMethodRequest: UpdateSubscriptionDefaultPaymentMethodRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<UpdateSubscriptionTier200Response>;

  /**
   *
   * @summary Update the subscription tier of an existing subscription
   * @param {UpdateSubscriptionTierRequest} updateSubscriptionTierRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateSubscriptionTier(
    updateSubscriptionTierRequest: UpdateSubscriptionTierRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<UpdateSubscriptionTier200Response>;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
  /**
   *
   * @summary Create a stripe setup intent, for the purpose of adding a new payment method.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createStripeSetupIntent(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createStripeSetupIntent(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a subscription
   * @param {CreateSubscriptionRequest} createSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createSubscription(
    createSubscriptionRequest: CreateSubscriptionRequest,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createSubscription(createSubscriptionRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Detach an existing payment method from a BP user
   * @param {string} paymentMethodId The payment method ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public detachPaymentMethod(
    paymentMethodId: string,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .detachPaymentMethod(paymentMethodId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Call an external service method
   * @param {ExternalServiceMethodRequest} externalServiceMethodRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public externalServiceMethod(
    externalServiceMethodRequest: ExternalServiceMethodRequest,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .externalServiceMethod(externalServiceMethodRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve the payment methods of the BP user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPaymentMethods(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getPaymentMethods(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve the subscription of the BP user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getSubscription(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getSubscription(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve the subscription tier prices
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getSubscriptionTierPrices(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getSubscriptionTierPrices(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve an upcoming invoice based on a new subscription tier
   * @param {SubscriptionTier} newSubscriptionTier The new subscription tier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUpcomingInvoice(
    newSubscriptionTier: SubscriptionTier,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getUpcomingInvoice(newSubscriptionTier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update an existing payment method of the BP user
   * @param {string} paymentMethodId The payment method ID
   * @param {UpdatePaymentMethodRequest} updatePaymentMethodRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updatePaymentMethod(
    paymentMethodId: string,
    updatePaymentMethodRequest: UpdatePaymentMethodRequest,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updatePaymentMethod(paymentMethodId, updatePaymentMethodRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the default payment method of an existing subscription
   * @param {UpdateSubscriptionDefaultPaymentMethodRequest} updateSubscriptionDefaultPaymentMethodRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateSubscriptionDefaultPaymentMethod(
    updateSubscriptionDefaultPaymentMethodRequest: UpdateSubscriptionDefaultPaymentMethodRequest,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateSubscriptionDefaultPaymentMethod(
        updateSubscriptionDefaultPaymentMethodRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the subscription tier of an existing subscription
   * @param {UpdateSubscriptionTierRequest} updateSubscriptionTierRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateSubscriptionTier(
    updateSubscriptionTierRequest: UpdateSubscriptionTierRequest,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateSubscriptionTier(updateSubscriptionTierRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
